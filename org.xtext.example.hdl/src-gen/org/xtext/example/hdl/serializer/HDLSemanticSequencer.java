/*
 * generated by Xtext 2.35.0
 */
package org.xtext.example.hdl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.hdl.hDL.HDLPackage;
import org.xtext.example.hdl.hDL.Model;
import org.xtext.example.hdl.hDL.PTArchDecl;
import org.xtext.example.hdl.hDL.PTEntityDecl;
import org.xtext.example.hdl.hDL.PTIdentifier;
import org.xtext.example.hdl.hDL.PTSignalAssign;
import org.xtext.example.hdl.hDL.PTSignalDecl;
import org.xtext.example.hdl.services.HDLGrammarAccess;

@SuppressWarnings("all")
public class HDLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private HDLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == HDLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case HDLPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case HDLPackage.PT_ARCH_DECL:
				sequence_arch_decl(context, (PTArchDecl) semanticObject); 
				return; 
			case HDLPackage.PT_ENTITY_DECL:
				sequence_entity_decl(context, (PTEntityDecl) semanticObject); 
				return; 
			case HDLPackage.PT_IDENTIFIER:
				if (rule == grammarAccess.getLhsRule()) {
					sequence_lhs(context, (PTIdentifier) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRhsRule()) {
					sequence_rhs(context, (PTIdentifier) semanticObject); 
					return; 
				}
				else break;
			case HDLPackage.PT_SIGNAL_ASSIGN:
				sequence_signal_assign(context, (PTSignalAssign) semanticObject); 
				return; 
			case HDLPackage.PT_SIGNAL_DECL:
				sequence_signal_decl(context, (PTSignalDecl) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (entityDecl=entity_decl archDecl=arch_decl)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HDLPackage.Literals.MODEL__ENTITY_DECL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HDLPackage.Literals.MODEL__ENTITY_DECL));
			if (transientValues.isValueTransient(semanticObject, HDLPackage.Literals.MODEL__ARCH_DECL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HDLPackage.Literals.MODEL__ARCH_DECL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelAccess().getEntityDeclEntity_declParserRuleCall_0_0(), semanticObject.getEntityDecl());
		feeder.accept(grammarAccess.getModelAccess().getArchDeclArch_declParserRuleCall_1_0(), semanticObject.getArchDecl());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     arch_decl returns PTArchDecl
	 *
	 * Constraint:
	 *     (entityId=[PTEntityDecl|ID] signalDecls+=signal_decl* signalAssign+=signal_assign*)
	 * </pre>
	 */
	protected void sequence_arch_decl(ISerializationContext context, PTArchDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     entity_decl returns PTEntityDecl
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_entity_decl(ISerializationContext context, PTEntityDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HDLPackage.Literals.PT_ENTITY_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HDLPackage.Literals.PT_ENTITY_DECL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntity_declAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     lhs returns PTIdentifier
	 *
	 * Constraint:
	 *     id=[PTSignalDecl|ID]
	 * </pre>
	 */
	protected void sequence_lhs(ISerializationContext context, PTIdentifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HDLPackage.Literals.PT_IDENTIFIER__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HDLPackage.Literals.PT_IDENTIFIER__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLhsAccess().getIdPTSignalDeclIDTerminalRuleCall_0_1(), semanticObject.eGet(HDLPackage.Literals.PT_IDENTIFIER__ID, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     rhs returns PTIdentifier
	 *
	 * Constraint:
	 *     id=[PTSignalDecl|ID]
	 * </pre>
	 */
	protected void sequence_rhs(ISerializationContext context, PTIdentifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HDLPackage.Literals.PT_IDENTIFIER__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HDLPackage.Literals.PT_IDENTIFIER__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRhsAccess().getIdPTSignalDeclIDTerminalRuleCall_0_1(), semanticObject.eGet(HDLPackage.Literals.PT_IDENTIFIER__ID, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     signal_assign returns PTSignalAssign
	 *
	 * Constraint:
	 *     (lhs=lhs rhs=rhs)
	 * </pre>
	 */
	protected void sequence_signal_assign(ISerializationContext context, PTSignalAssign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HDLPackage.Literals.PT_SIGNAL_ASSIGN__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HDLPackage.Literals.PT_SIGNAL_ASSIGN__LHS));
			if (transientValues.isValueTransient(semanticObject, HDLPackage.Literals.PT_SIGNAL_ASSIGN__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HDLPackage.Literals.PT_SIGNAL_ASSIGN__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSignal_assignAccess().getLhsLhsParserRuleCall_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getSignal_assignAccess().getRhsRhsParserRuleCall_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     signal_decl returns PTSignalDecl
	 *
	 * Constraint:
	 *     (name=ID signalType=ID)
	 * </pre>
	 */
	protected void sequence_signal_decl(ISerializationContext context, PTSignalDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HDLPackage.Literals.PT_SIGNAL_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HDLPackage.Literals.PT_SIGNAL_DECL__NAME));
			if (transientValues.isValueTransient(semanticObject, HDLPackage.Literals.PT_SIGNAL_DECL__SIGNAL_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HDLPackage.Literals.PT_SIGNAL_DECL__SIGNAL_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSignal_declAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSignal_declAccess().getSignalTypeIDTerminalRuleCall_3_0(), semanticObject.getSignalType());
		feeder.finish();
	}
	
	
}
